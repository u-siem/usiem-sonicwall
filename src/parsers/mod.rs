use chrono::prelude::{TimeZone, Utc};
use std::borrow::Cow;
use std::collections::BTreeMap;
use usiem::events::field::{SiemField, SiemIp};
use usiem::events::firewall::{FirewallEvent, FirewallOutcome};
use usiem::events::webproxy::{WebProxyEvent,WebProxyOutcome,WebProxyRuleCategory};
use usiem::events::common::{WebProtocol, HttpMethod};
use usiem::events::protocol::NetworkProtocol;
use usiem::events::{SiemEvent, SiemLog};
use usiem::utilities::ip_utils::{port_to_u16};
use usiem::events::field_dictionary;
mod proxy_category;

//TODO: Improve CORE features: ParseError=[MismatchedDevice, ParserError, LogFormatError]
// MismatchedDevice -> Indicate that the log is not generated by this kind of device
// ParserError -> Maybe the format of the logs has changed (Product Updated?) Typical in Symantec products
// LogFormatError -> The parser tells that there are errors in this logs
pub fn parse_log(log: SiemLog) -> Result<SiemLog, SiemLog> {
    let log_line = log.message();
    let start_log_pos = match log_line.find(" id=") {
        Some(val) => val + 1,
        None => return Err(log),
    };
    let syslog_header = &log_line[0..start_log_pos];
    let log_content = &log_line[start_log_pos..];

    let mut syslog_hdr_content = Vec::new();
    let syslog_start = match syslog_header.find(">") {
        Some(val) => val,
        None => return Err(log),
    };
    syslog_hdr_content.push(&syslog_header[1..syslog_start]); //Add <XXX>
    let mut last_pos = 0;
    let init_pos = syslog_start + 1;
    for (pos, c) in syslog_header[init_pos..].char_indices() {
        if c == ' ' {
            syslog_hdr_content.push(&syslog_header[(init_pos + last_pos)..(init_pos + pos)]);
            last_pos = pos + 1;
        }
    }
    let origin = log.origin().clone();
    let mut observer_name: Option<SiemField> = None;
    let mut observer_ip: Option<SiemIp> = None;
    match syslog_hdr_content.get(4) {
        Some(val1) => match SiemIp::from_ip_str((*val1).to_string()) {
            Ok(val_ip) => {
                observer_ip = Some(val_ip);
            }
            Err(_) => observer_name = Some(SiemField::from_str((*val1).to_string())),
        },
        _ => {}
    };
    match syslog_hdr_content.get(5) {
        Some(val1) => match SiemIp::from_ip_str((*val1).to_string()) {
            Ok(val_ip) => {
                observer_ip = Some(val_ip);
            }
            Err(_) => observer_name = Some(SiemField::from_str((*val1).to_string())),
        },
        _ => {}
    };
    let field_map = extract_fields(log_line);

    let event_created = match field_map.get("time") {
        Some(val) => {
            //FORMAT: 2021-02-05 01:02:03 UTC
            match Utc.datetime_from_str(val, "%Y-%m-%d %H:%M:%S UTC") {
                Ok(timestamp) => timestamp.timestamp_millis(),
                Err(_err) => return Err(log),
            }
        }
        None => return Err(log),
    };
    let service = match field_map.get("id") {
        Some(val) => val.to_string(),
        None => return Err(log),
    };
    let observer_id = match field_map.get("sn") {
        Some(val) => val.to_string(),
        None => return Err(log),
    };

    let mut log = match observer_ip {
        Some(observer_ip) => {
            SiemLog::new(log_content.to_owned(), log.event_received(), observer_ip)
        }
        None => SiemLog::new(log_content.to_owned(), log.event_received(), origin),
    };
    log.set_event_created(event_created);
    log.set_vendor(Cow::Borrowed("SonicWall"));
    log.set_product(Cow::Borrowed("SonicWall"));
    log.set_service(Cow::Owned(service));
    log.set_category(Cow::Borrowed("Firewall"));
    log.add_field("observer.id", SiemField::Text(Cow::Owned(observer_id)));
    match observer_name {
        Some(val) => {
            log.add_field("observer.name", val);
        }
        None => {}
    };

    sonicwall_event_selector(field_map, log)
}

fn sonicwall_event_selector<'a>(
    field_map: BTreeMap<Cow<'a, str>, Cow<'a, str>>,
    mut log: SiemLog,
) -> Result<SiemLog, SiemLog> {
    //fw=Firewall WAN IP
    //pri=Message priority
    //c=Message category (legacy only)
    //m=Message ID
    //msg
    //sess=Pre-defined string indicating session type
    /*
        None - the starting session type when user authentication is still pending or just started
        Web - identified as a Web browser session
        Portal - SSL-VPN portal login
        l2tpc - L2TP client session
        vpnc - VPN client session
        sslvpnc - SSL-VPN client session
        Auto - Auto-logged in session, for example Single Sign On (SSO)
        Other - none of the known types
        CLI - indicates a CLI session
    */
    //n=Message count
    //usr=Displays the user name
    //src=Indicates the source IP address, and optionally, port, network interface, and resolved name
    //dst=Destination IP address, and optionally, port, network interface, and resolved name
    //srcMac=Source MAC Address
    //dstMac=Destination MAC Address
    //proto=Diplays the protocol information(rendered as “proto=[protocol]” or just “[proto]/[service]”)
    //rcvd=Indicates the number of bytes received within connection
    //rule=Used to identify a policy or a rule associated with an even
    let user_name = match field_map.get("usr") {
        Some(val) => Some(val.to_string()),
        None => None
    };
    let (source_ip, source_port, source_interface) = match field_map.get("src") {
        Some(val) => {
            //add_field_or_not(&mut log, src_ip, "source.ip");
            //add_field_or_not(&mut log, src_port, "source.port");
            //add_field_or_not(&mut log, src_intrf, "source.interface");
            get_ip_values(val)
        }
        None => {(None,None,None)}
    };
    let source_interface = match source_interface {
        Some(val) => val,
        None => Cow::Borrowed("")
    };
    let (destination_ip, destination_port, destination_interface) = match field_map.get("dst") {
        Some(val) => {
            get_ip_values(val)
        }
        None => {(None,None,None)}
    };
    let destination_interface = match destination_interface {
        Some(val) => val,
        None => Cow::Borrowed("")
    };
    add_value_or_not(&mut log, field_map.get("srcMac"), "source.mac");
    add_value_or_not(&mut log, field_map.get("dstMac"), "destination.mac");
    let (network_transport,network_protocol) = match field_map.get("proto") {
        Some(val) => {
            let mut pos = 0;
            let mut net_trans = NetworkProtocol::UNKNOWN;
            let mut net_proto : Option<Cow<'static,str>> = None;
            for s in val.split("/") {
                if pos == 0 {
                    net_trans = parse_network_transport(s);
                } else {
                    match s.chars().next() {
                        Some(c) => {
                            if !c.is_alphabetic() {
                                net_proto = Some(Cow::Owned(s.to_string()))
                            }
                        }
                        None => {}
                    }
                    break;
                }
                pos += 1;
            }
            (net_trans, net_proto)
        }
        None => (NetworkProtocol::UNKNOWN,None)
    };

    let in_bytes = match field_map.get("rcvd") {
        Some(val) => {
            match val.parse::<u32>() {
                Ok(val) => val,
                Err(_) => 0 as u32
            }
        }
        None => 0 as u32
    };
    let out_bytes = match field_map.get("sent") {
        Some(val) => {
            match val.parse::<u32>() {
                Ok(val) => val,
                Err(_) => 0 as u32
            }
        }
        None => 0 as u32
    };
    match field_map.get("sess") {
        Some(sess) => {
            log.add_field("event.dataset", SiemField::from_str(sess.to_string()));
        }
        None => {}
    }
    match field_map.get("sess") {
        Some(sess) => {
            log.add_field("event.dataset", SiemField::from_str(sess.to_string()));
        }
        None => {}
    }
    let event_code = match field_map.get("c") {
        Some(val) => {
            match val.parse::<u32>() {
                Ok(val) => {
                    log.add_field(field_dictionary::EVENT_CODE, SiemField::U32(val));
                    val
                },
                Err(_) => {0}
            }
        }
        None => {0}
    };
    let event_subcode = match field_map.get("m") {
        Some(val) => {
            match val.parse::<u32>() {
                Ok(val) => {
                    log.add_field("event.subcode", SiemField::U32(val));
                    val
                },
                Err(_) => {0}
            }
        }
        None => {0}
    };
    match &network_protocol {
        Some(network_protocol) => {
            log.add_field(field_dictionary::NETWORK_PROTOCOL, SiemField::from_str(network_protocol.clone()));
        },
        None => {}
    }
    
    match event_code {
        1024 => {
            //Traffic info
            match event_subcode {
                97 => {
                    //URL Traffic
                    let url_domain = match field_map.get("dstname") {
                        Some(val) => {
                            Cow::Owned(val.to_string())
                        }
                        None => Cow::Borrowed("")
                    };
                    println!("{:?}",field_map);
                    let (url_path, url_query) = match field_map.get("arg") {
                        Some(val) => {
                            println!("{}",val);
                            if val.starts_with("/") {
                                let pos = val.find("?");
                                match pos {
                                    Some(pos) => {
                                        log.add_field(field_dictionary::URL_PATH, SiemField::from_str(Cow::Owned((&val[..pos]).to_string())));
                                        log.add_field(field_dictionary::URL_QUERY, SiemField::from_str(Cow::Owned((&val[pos..]).to_string())));
                                        (Cow::Owned((&val[..pos]).to_string()),Cow::Owned((&val[pos..]).to_string()))
                                    },
                                    None => {
                                        log.add_field(field_dictionary::URL_PATH, SiemField::from_str(Cow::Owned((&val[..]).to_string())));
                                        (Cow::Owned((&val[..]).to_string()),Cow::Borrowed(""))
                                    }
                                }
                            }else{
                                (Cow::Borrowed(""),Cow::Borrowed(""))
                            }
                        }
                        None => (Cow::Borrowed(""),Cow::Borrowed(""))
                    };
                    let status_code = match field_map.get("result") {
                        Some(val) => {
                            match val.parse::<u32>() {
                                Ok(val) => val,
                                Err(_) => 0
                            }
                        }
                        None => 0
                    };
                    let url_full = Cow::Owned(format!("{}{}{}",url_domain,url_path,url_query));
                    let http_method = match field_map.get("op") {
                        Some(val) => {
                            http_operation(val)
                        }
                        None => HttpMethod::CONNECT
                    };
                    let (rule_name,url_category) = match field_map.get("Category") {
                        Some(val) => (Cow::Owned(val.to_string()),proxy_category::web_category(val)),
                        None => (Cow::Borrowed(""),WebProxyRuleCategory::Uncategorized)
                    };
                    //TODO: WebProxy
                    let web_protocol = match network_protocol {
                        Some(val) => parse_network_protocol(&val),
                        None => WebProtocol::HTTP
                    };
                    let user_name = match &user_name {
                        Some(user_name) => Cow::Owned(user_name.clone()),
                        None => Cow::Borrowed("")
                    };

                    let event = webproxy_event(source_ip.clone(), url_full, destination_ip.clone(), destination_port, url_domain, web_protocol,  WebProxyOutcome::ALLOW, in_bytes, out_bytes, user_name, Cow::Borrowed(""), Some(rule_name), Some(url_category), status_code, http_method);
                    match event {
                        Some(event) => {log.set_event(SiemEvent::WebProxy(event));},
                        None => {}
                    };
                },
                537 => {
                    //Normal Traffic
                    let event = firewall_event(source_ip.clone(),source_port,source_interface.clone(),destination_ip.clone(),destination_port,destination_interface.clone(),network_transport.clone(),FirewallOutcome::ALLOW, in_bytes, out_bytes);
                    match event {
                        Some(event) => {log.set_event(SiemEvent::Firewall(event));},
                        None => {}
                    };
                },
                1153 => {
                    //VPN Traffic
                    let event = firewall_event(source_ip.clone(),source_port,source_interface.clone(),destination_ip.clone(),destination_port,destination_interface.clone(),network_transport.clone(),FirewallOutcome::ALLOW, in_bytes, out_bytes);
                    match event {
                        Some(event) => {log.set_event(SiemEvent::Firewall(event));},
                        None => {}
                    };
                },
                262144 => {
                    //OpenConnection
                    let event = firewall_event(source_ip.clone(),source_port,source_interface.clone(),destination_ip.clone(),destination_port,destination_interface.clone(),network_transport.clone(),FirewallOutcome::OPEN, in_bytes, out_bytes);
                    match event {
                        Some(event) => {log.set_event(SiemEvent::Firewall(event));},
                        None => {}
                    };
                },
                _ => {
                    //TODO
                }
            }
        },
        _ => {
            //TODO
        }
    }
    match log.event() {
        SiemEvent::Unknown => {
            //Add values
            match source_ip {
                Some(ip) => {log.add_field(field_dictionary::SOURCE_IP, SiemField::IP(ip));},
                None =>  {}
            }
            match destination_ip {
                Some(ip) => {log.add_field(field_dictionary::DESTINATION_IP, SiemField::IP(ip));},
                None =>  {}
            }
            match source_port {
                Some(port) => {log.add_field(field_dictionary::SOURCE_PORT, SiemField::U32(port as u32));},
                None =>  {}
            }
            match destination_port {
                Some(port) => {log.add_field(field_dictionary::DESTINATION_PORT, SiemField::U32(port as u32));},
                None =>  {}
            }
            log.add_field(field_dictionary::IN_INTERFACE, SiemField::Text(source_interface));
            log.add_field(field_dictionary::OUT_INTERFACE, SiemField::Text(destination_interface));
            log.add_field(field_dictionary::SOURCE_BYTES, SiemField::U64(out_bytes as u64));
            log.add_field(field_dictionary::DESTINATION_BYTES, SiemField::U64(in_bytes as u64));
            log.add_field(field_dictionary::NETWORK_TRANSPORT, SiemField::Text(Cow::Owned(network_transport.to_string())));
            match user_name {
                Some(val) => {
                    log.add_field(field_dictionary::USER_NAME, SiemField::User(val));
                },
                None => {}
            }
        },
        _ => {}
    }
    Ok(log)
}

fn parse_network_transport(protocol : &str) -> NetworkProtocol {
    match protocol {
        "tcp" => NetworkProtocol::TCP,
        "udp" => NetworkProtocol::UDP,
        _ => NetworkProtocol::OTHER(Cow::Owned(protocol.to_uppercase())),
    }
}
fn parse_network_protocol(protocol : &str) -> WebProtocol {
    match protocol {
        "http" => WebProtocol::HTTP,
        "https" => WebProtocol::HTTPS,
        _ => WebProtocol::UNKNOWN(protocol.to_uppercase()),
    }
}

fn webproxy_event(source_ip : Option<SiemIp>,url : Cow<'static,str>, destination_ip : Option<SiemIp>, destination_port : Option<u16>,domain : Cow<'static,str>, protocol : WebProtocol, outcome : WebProxyOutcome, in_bytes : u32, out_bytes : u32,user_name : Cow<'static,str>,mime_type : Cow<'static,str>, rule_name : Option<Cow<'static,str>>, rule_category : Option<WebProxyRuleCategory>,http_code : u32, http_method : HttpMethod) -> Option<WebProxyEvent> {
    match (source_ip,destination_ip,destination_port) {
        (Some(source_ip),Some(destination_ip),Some(destination_port)) => {
            Some(WebProxyEvent {
                source_ip,
                destination_ip,
                destination_port,
                in_bytes,
                out_bytes,
                http_code,
                http_method,
                url,
                domain,
                protocol,
                user_name,
                mime_type,
                outcome,
                rule_name,
                rule_category
            })
        },
        _ => None
    }
}

fn http_operation(operation : &str) -> HttpMethod {
    match operation {
        "0" => HttpMethod::OPTIONS, //NO OPERATION
        "1" => HttpMethod::GET,
        "2" => HttpMethod::POST,
        "3" => HttpMethod::UNKNOWN("HEAD".to_owned()),
        _ => HttpMethod::OPTIONS
    }
}
fn firewall_event(source_ip : Option<SiemIp>,source_port : Option<u16>,source_if : Cow<'static,str>, destination_ip : Option<SiemIp>, destination_port : Option<u16>,destination_if : Cow<'static,str>, network_protocol : NetworkProtocol, outcome : FirewallOutcome, in_bytes : u32, out_bytes : u32) -> Option<FirewallEvent> {
    match (source_ip,source_port,destination_ip,destination_port) {
        (Some(source_ip),Some(source_port),Some(destination_ip),Some(destination_port)) => {
            Some(FirewallEvent {
                destination_ip,
                destination_port,
                source_ip,
                source_port,
                in_bytes : in_bytes,
                out_bytes : out_bytes,
                in_interface : source_if,
                out_interface : destination_if,
                outcome : outcome,
                network_protocol
            })
        },
        _ => None
    }
}


fn add_value_or_not<'a>(
    log: &'a mut SiemLog,
    field_value: Option<&Cow<'a, str>>,
    name: &'static str,
) {
    match field_value {
        Some(val) => {
            log.add_field(name, SiemField::Text(Cow::Owned(val.to_string())));
        }
        None => {}
    };
}

fn get_ip_values<'a>(value: &'a str) -> (Option<SiemIp>, Option<u16>, Option<Cow<'static, str>>) {
    let mut pos = 0;
    let mut src_ip = None;
    let mut src_port = None;
    let mut src_intrf = None;
    for s in value.split(":") {
        match pos {
            0 => {
                src_ip = match SiemIp::from_ip_str(s.to_string()) {
                    Ok(ip) => Some(ip),
                    Err(_) => None,
                };
            }
            1 => {
                let port = match port_to_u16(s) {
                    Ok(val) => val,
                    Err(_) => {
                        break;
                    }
                };
                src_port = Some(port);
            }
            2 => {
                src_intrf = Some(Cow::Owned(s.to_string()));
            }
            _ => {
                break;
            }
        }
        pos += 1;
    }
    (src_ip, src_port, src_intrf)
}


pub fn extract_fields<'a>(message: &'a str) -> BTreeMap<Cow<'a, str>, Cow<'a, str>> {
    let mut field_map = BTreeMap::new();
    let mut start_field = 0;
    let mut end_field = 0;
    let mut start_val = 0;
    let mut found = false;
    let mut is_string = false;
    let mut last_char = ' ';
    let mut cleaned = true;
    for (i, c) in message.char_indices() {
        if !found && c.is_whitespace() {
            if !cleaned {
                start_field = 0;
                end_field = 0;
                start_val = 0;
                found = false;
                is_string = false;
                cleaned = true;
            }
        } else {
            if found {
                if end_field <= start_field {
                    if c == '=' {
                        end_field = i;
                    } else if !c.is_alphanumeric() {
                        start_field = 0;
                        end_field = 0;
                        start_val = 0;
                        found = false;
                        is_string = false;
                        cleaned = true;
                    }
                } else {
                    if start_val == 0 {
                        // Set starting pos for value
                        if c == '"' {
                            //String value
                            start_val = i + 1;
                            is_string = true;
                        } else if !c.is_whitespace() {
                            start_val = i;
                            is_string = false;
                        } else {
                            start_field = 0;
                            end_field = 0;
                            start_val = 0;
                            found = false;
                            is_string = false;
                            cleaned = true;
                        }
                    } else {
                        //Search end pos for value
                        if is_string {
                            if c == '"' && last_char != '"' {
                                field_map.insert(
                                    Cow::Borrowed(&message[start_field..end_field]),
                                    Cow::Borrowed(&message[start_val..i]),
                                );
                                start_field = 0;
                                end_field = 0;
                                start_val = 0;
                                found = false;
                                is_string = false;
                                cleaned = true;
                            }
                        } else {
                            if c.is_whitespace() {
                                field_map.insert(
                                    Cow::Borrowed(&message[start_field..end_field]),
                                    Cow::Borrowed(&message[start_val..i]),
                                );
                                start_field = 0;
                                end_field = 0;
                                start_val = 0;
                                found = false;
                                is_string = false;
                                cleaned = true;
                            }
                        }
                    }
                }
            } else {
                if c.is_alphanumeric() {
                    start_field = i;
                    found = true;
                } else {
                    start_field = 0;
                    end_field = 0;
                    start_val = 0;
                    found = false;
                    is_string = false;
                    cleaned = true;
                }
            }
        }
        last_char = c;
    }
    field_map
}

#[cfg(test)]
mod filterlog_tests {
    use super::{extract_fields, parse_log};
    use std::borrow::Cow;
    use usiem::events::field::SiemField;
    use usiem::events::field::SiemIp;
    use usiem::events::{SiemLog, SiemEvent};
    use usiem::utilities::ip_utils::ipv4_from_str;

    #[test]
    fn test_extract_fields() {
        let log = "May 11 03:28:24 10.1.99.1   id=firewall sn=SERIALNUMBER111 time=\"2021-02-05 01:02:03 UTC\" fw=111.222.111.222 pri=6 c=1024 m=1153 msg=\"SSL VPN Traffic\" sess=\"sslvpnc\" n=1234567890 usr=\"test@usiem.com\" src=10.1.2.3:3080:X6-V80 dst=10.2.3.4:50005:X1 srcMac=98:90:96:de:f1:78 dstMac=ec:f4:bb:fb:f7:f6 proto=tcp/50005 rcvd=392 rule=\"123 (SSLVPN->NET_RRHH1)\"";
        let map = extract_fields(log);
        assert_eq!(map.get("id"), Some(&Cow::Borrowed("firewall")));
        assert_eq!(map.get("sn"), Some(&Cow::Borrowed("SERIALNUMBER111")));
        assert_eq!(
            map.get("time"),
            Some(&Cow::Borrowed("2021-02-05 01:02:03 UTC"))
        );
        assert_eq!(map.get("fw"), Some(&Cow::Borrowed("111.222.111.222")));
        assert_eq!(map.get("pri"), Some(&Cow::Borrowed("6")));
        assert_eq!(map.get("c"), Some(&Cow::Borrowed("1024")));
        assert_eq!(map.get("m"), Some(&Cow::Borrowed("1153")));
        assert_eq!(map.get("msg"), Some(&Cow::Borrowed("SSL VPN Traffic")));
        assert_eq!(map.get("sess"), Some(&Cow::Borrowed("sslvpnc")));
        assert_eq!(map.get("n"), Some(&Cow::Borrowed("1234567890")));
        assert_eq!(map.get("usr"), Some(&Cow::Borrowed("test@usiem.com")));
        assert_eq!(map.get("src"), Some(&Cow::Borrowed("10.1.2.3:3080:X6-V80")));
        assert_eq!(map.get("dst"), Some(&Cow::Borrowed("10.2.3.4:50005:X1")));
        assert_eq!(map.get("srcMac"), Some(&Cow::Borrowed("98:90:96:de:f1:78")));
        assert_eq!(map.get("dstMac"), Some(&Cow::Borrowed("ec:f4:bb:fb:f7:f6")));
        assert_eq!(map.get("proto"), Some(&Cow::Borrowed("tcp/50005")));
        assert_eq!(map.get("rcvd"), Some(&Cow::Borrowed("392")));
        assert_eq!(
            map.get("rule"),
            Some(&Cow::Borrowed("123 (SSLVPN->NET_RRHH1)"))
        );
        assert_eq!(map.len(), 18);
    }
    #[test]
    fn test_extract_fields_with_errors() {
        let log = "Feb 5 01:02:03 10.1.99.1 10.1.99.1 aaa= 123%= id=firewall sn=SERIALNUMBER111 time=\"2021-02-05 01:02:03 UTC\" 123%= 123%=fw=111.222.111.222 pri=6 c=1024 m=1153 msg=\"SSL VPN Traffic\" sess=\"sslvpnc\" n=1234567890 usr=\"test@usiem.com\" src=10.1.2.3:3080:X6-V80 dst=10.2.3.4:50005:X1 srcMac=98:90:96:de:f1:78 dstMac=ec:f4:bb:fb:f7:f6 proto=tcp/50005 rcvd=392 rule=\"123 (SSLVPN->NET_RRHH1)\"";
        let map = extract_fields(log);
        assert_eq!(map.get("id"), Some(&Cow::Borrowed("firewall")));
        assert_eq!(map.get("sn"), Some(&Cow::Borrowed("SERIALNUMBER111")));
        assert_eq!(
            map.get("time"),
            Some(&Cow::Borrowed("2021-02-05 01:02:03 UTC"))
        );
        assert_eq!(map.get("fw"), Some(&Cow::Borrowed("111.222.111.222")));
        assert_eq!(map.get("pri"), Some(&Cow::Borrowed("6")));
        assert_eq!(map.get("c"), Some(&Cow::Borrowed("1024")));
        assert_eq!(map.get("m"), Some(&Cow::Borrowed("1153")));
        assert_eq!(map.get("msg"), Some(&Cow::Borrowed("SSL VPN Traffic")));
        assert_eq!(map.get("sess"), Some(&Cow::Borrowed("sslvpnc")));
        assert_eq!(map.get("n"), Some(&Cow::Borrowed("1234567890")));
        assert_eq!(map.get("usr"), Some(&Cow::Borrowed("test@usiem.com")));
        assert_eq!(map.get("src"), Some(&Cow::Borrowed("10.1.2.3:3080:X6-V80")));
        assert_eq!(map.get("dst"), Some(&Cow::Borrowed("10.2.3.4:50005:X1")));
        assert_eq!(map.get("srcMac"), Some(&Cow::Borrowed("98:90:96:de:f1:78")));
        assert_eq!(map.get("dstMac"), Some(&Cow::Borrowed("ec:f4:bb:fb:f7:f6")));
        assert_eq!(map.get("proto"), Some(&Cow::Borrowed("tcp/50005")));
        assert_eq!(map.get("rcvd"), Some(&Cow::Borrowed("392")));
        assert_eq!(
            map.get("rule"),
            Some(&Cow::Borrowed("123 (SSLVPN->NET_RRHH1)"))
        );
        assert_eq!(map.len(), 18);
    }
    #[test]
    fn test_parser() {
        let log = "<12>Feb 5 01:02:03 10.1.99.1 10.1.99.1 aaa= 123%= id=firewall sn=SERIALNUMBER111 time=\"2021-02-05 01:02:03 UTC\" 123%= 123%=fw=111.222.111.222 pri=6 c=1024 m=1153 msg=\"SSL VPN Traffic\" sess=\"sslvpnc\" n=1234567890 usr=\"test@usiem.com\" src=10.1.2.3:3080:X6-V80 dst=10.2.3.4:50005:X1 srcMac=98:90:96:de:f1:78 dstMac=ec:f4:bb:fb:f7:f6 proto=tcp/50005 rcvd=392 rule=\"123 (SSLVPN->NET_RRHH1)\"";
        let log = SiemLog::new(log.to_string(), 0, SiemIp::V4(0));
        let siem_log = parse_log(log);
        match siem_log {
            Ok(log) => {
                assert_eq!(log.service(), "firewall");

                assert_eq!(
                    log.field("observer.id"),
                    Some(&SiemField::from_str("SERIALNUMBER111"))
                );
                assert_eq!(log.field("observer.name"), None);
                assert_eq!(
                    log.origin(),
                    &SiemIp::V4(ipv4_from_str("10.1.99.1").unwrap())
                );
                assert_eq!(
                    log.field("source.mac"),
                    Some(&SiemField::from_str("98:90:96:de:f1:78"))
                );
                assert_eq!(
                    log.field("destination.mac"),
                    Some(&SiemField::from_str("ec:f4:bb:fb:f7:f6"))
                );
                assert_eq!(
                    log.field("source.ip"),
                    Some(&SiemField::IP(SiemIp::V4(
                        ipv4_from_str("10.1.2.3").unwrap()
                    )))
                );
                assert_eq!(
                    log.field("destination.ip"),
                    Some(&SiemField::IP(SiemIp::V4(
                        ipv4_from_str("10.2.3.4").unwrap()
                    )))
                );
            }
            Err(_) => assert_eq!(1, 0),
        }
    }
    #[test]
    fn test_parser_2() {
        let log = "<12>Feb 5 01:02:03 FWSonicWall 10.1.99.1 aaa= 123%= id=firewall sn=SERIALNUMBER111 time=\"2021-02-05 01:02:03 UTC\" 123%= 123%=fw=111.222.111.222 pri=6 c=1024 m=1153 msg=\"SSL VPN Traffic\" sess=\"sslvpnc\" n=1234567890 usr=\"test@usiem.com\" src=10.1.2.3:3080:X6-V80 dst=10.2.3.4:50005:X1 srcMac=98:90:96:de:f1:78 dstMac=ec:f4:bb:fb:f7:f6 proto=tcp/50005 rcvd=392 rule=\"123 (SSLVPN->NET_RRHH1)\"";
        let log = SiemLog::new(log.to_string(), 0, SiemIp::V4(0));
        let siem_log = parse_log(log);
        match siem_log {
            Ok(log) => {
                assert_eq!(log.service(), "firewall");

                assert_eq!(
                    log.field("observer.id"),
                    Some(&SiemField::from_str("SERIALNUMBER111"))
                );
                assert_eq!(
                    log.field("observer.name"),
                    Some(&SiemField::from_str("FWSonicWall"))
                );
                assert_eq!(
                    log.origin(),
                    &SiemIp::V4(ipv4_from_str("10.1.99.1").unwrap())
                );
                assert_eq!(
                    log.field("source.mac"),
                    Some(&SiemField::from_str("98:90:96:de:f1:78"))
                );
                assert_eq!(
                    log.field("destination.mac"),
                    Some(&SiemField::from_str("ec:f4:bb:fb:f7:f6"))
                );
                assert_eq!(
                    log.field("source.ip"),
                    Some(&SiemField::IP(SiemIp::V4(
                        ipv4_from_str("10.1.2.3").unwrap()
                    )))
                );
                assert_eq!(
                    log.field("destination.ip"),
                    Some(&SiemField::IP(SiemIp::V4(
                        ipv4_from_str("10.2.3.4").unwrap()
                    )))
                );
            }
            Err(_) => assert_eq!(1, 0),
        }
    }

    #[test]
    fn test_parser_web_connection() {
        let log = "<134>Feb 5 01:02:03 FWSonicWall 10.1.99.1 id=firewall sn=18B1690729A8 time=\"2016-06-16 17:21:40 UTC\" fw=10.205.123.15 pri=6 c=1024 m=97 app=48 n=9 src=192.168.168.10:52589:X0 dst=69.192.240.232:443:X1:a69-192-240-232.deploy.akamaitechnologies.com srcMac=98:90:96:de:f1:78 dstMac=ec:f4:bb:fb:f7:f6 proto=tcp/https op=1 sent=798 rcvd=12352 result=403 dstname=www.suntrust.com arg=/favicon.ico code=20 Category=\"Online Banking\"";
        let log = SiemLog::new(log.to_string(), 0, SiemIp::V4(0));
        let siem_log = parse_log(log);
        match siem_log {
            Ok(log) => {
                assert_eq!(log.service(), "firewall");

                assert_eq!(
                    log.field("observer.id"),
                    Some(&SiemField::from_str("18B1690729A8"))
                );
                assert_eq!(
                    log.field("observer.name"),
                    Some(&SiemField::from_str("FWSonicWall"))
                );
                assert_eq!(
                    log.origin(),
                    &SiemIp::V4(ipv4_from_str("10.1.99.1").unwrap())
                );
                assert_eq!(
                    log.field("source.mac"),
                    Some(&SiemField::from_str("98:90:96:de:f1:78"))
                );
                assert_eq!(
                    log.field("destination.mac"),
                    Some(&SiemField::from_str("ec:f4:bb:fb:f7:f6"))
                );
                assert_eq!(
                    log.field("source.ip"),
                    Some(&SiemField::IP(
                        SiemIp::from_ip_str("192.168.168.10").unwrap()
                    ))
                );
                assert_eq!(
                    log.field("destination.ip"),
                    Some(&SiemField::IP(SiemIp::V4(
                        ipv4_from_str("69.192.240.232").unwrap()
                    )))
                );
                assert_eq!(
                    log.field("url.domain"),
                    Some(&SiemField::from_str("www.suntrust.com"))
                );
                assert_eq!(
                    log.field("url.path"),
                    Some(&SiemField::from_str("/favicon.ico"))
                );
                match log.event() {
                    SiemEvent::WebProxy(_wp) => {

                    },
                    _ => {assert_eq!("WebProxy","Not WebProxy")}
                    
                }
            }
            Err(_) => assert_eq!(1, 0),
        }
    }
}
